"use strict";function safeAssign(e){let t={};for(let i in e){let r=Object.getOwnPropertyDescriptor(e,i);r&&r.writable&&(t[i]=e[i])}return t}Object.defineProperty(exports,"__esModule",{value:!0});const IS_PENDING=Symbol("isPending"),IS_FULFILLED=Symbol("isFulfulled"),IS_REJECTED=Symbol("isRejected"),IS_PAUSED=Symbol("isPaused");function fulfill(e,t){if("number"==typeof this.timeout&&this.timeout>0){const i=setTimeout(()=>{this.value=e,t(e),clearTimeout(i)},this.timeout)}else this.value=e,t(e)}function reject(e,t){if("number"==typeof this.timeout){const i=setTimeout(()=>{t(e),clearTimeout(i)},this.timeout)}else t(e)}class QueueNode{constructor(e){this.action=e.action,this.timeout=e.timeout||0,this.index=e.index,this.value=e.value,this[IS_PENDING]=!0,this[IS_FULFILLED]=!1,this[IS_REJECTED]=!1,this.fulfill=fulfill.bind(this),this.reject=reject.bind(this),this.next=void 0}resolve(e){return new Promise((t,i)=>{try{const r="function"==typeof this.action?this.action(e):this.action;if(r&&"function"==typeof r.then&&"function"==typeof r.catch)return r.then(e=>this.fulfill(e,t)).catch(e=>this.reject(e,i));this.fulfill(r,t)}catch(e){this.reject(e,i)}})}}function decompress(e){let t=[],i=e;for(;i;)t.push(i.value),i=i.next;return t}function handleResolve(e,t){for(;this.active<this.concurrency&&this.current;){this.active++;let i=this.current;this.current=i.next,i.action=this.action,i.resolve(i.value).then(i=>{0!=--this.active||this.current?this.resolve(e,t):e(decompress(this.root))},e=>{this[IS_REJECTED]=!0,t(e)})}}class Queue{constructor(e){this.action=e.action,this.concurrency=e.concurrency||1/0,this.values=e.values||[],this.active=0,this.timeout=e.timeout||0,this.current=void 0,this[IS_PAUSED]=!1,this[IS_REJECTED]=!1,this.root=void 0,this.length=0,this.decompress=(e.decompress||decompress).bind(this)}insert(...e){for(let t=0;t<e.length;t++)if(this.length++,this.root){let i=this.root;for(;i&&i.next;)i=i.next;i.next=new QueueNode({index:t,action:void 0,value:e[t],timeout:this.timeout})}else this.root=new QueueNode({index:t,action:void 0,value:e[t],timeout:this.timeout});return this.current=this.root,this}resolve(e,t){return!this.current||this[IS_REJECTED]||this[IS_PAUSED]?null:e&&t?void handleResolve.call(this,e,t):new Promise((e,t)=>{handleResolve.call(this,e,t)})}}function map(e,t,i,r){const n="function"==typeof i?i:r;return new Queue({action:e,concurrency:"number"==typeof i?i:void 0}).insert(...t).resolve().then(e=>n(null,e)).catch(n)}function parallel(e,t,i,r){const n="function"==typeof i?i:r;return new Queue({action:e=>{const{operation:i,key:r}=e;if("function"==typeof i){if(Array.isArray(t)){const e=t;return Promise.all([i(...e),r])}return[i(t),r]}return[i,r]},concurrency:"number"==typeof i?i:void 0,decompress:e=>{const t={};let i=e;for(;i;){const[e,r]=i.value;t[r]=e,i=i.next}return t}}).insert(...Object.keys(e).map(t=>[e[t],t])).resolve().then(e=>n(null,e)).catch(n)}function handleRecursiveParallel(e){return Object.keys(e).reduce((t,i)=>(e[i]&&"object"==typeof e[i]?t[i]=(()=>Promisie.parallel(handleRecursiveParallel(e[i]))):t[i]=i,t),{})}function settle(e,t,i){const r="function"==typeof t?t:i,n=[],s=[];return new Queue({action(e){if("function"==typeof e)try{const t=e();t&&"function"==typeof t.then&&"function"==typeof t.catch?t.then(e=>{n.push({value:e,status:"fulfilled"})},e=>{s.push({value:e,status:"rejected"})}):n.push({value:t,status:"fulfilled"})}catch(e){s.push({value:e,status:"rejected"})}else n.push({value:e,status:"fulfilled"});return null},decompress:e=>null,concurrency:"number"==typeof t?t:void 0}).insert(...e).resolve().then(()=>r(null,{fulfilled:n,rejected:s})).catch(r)}function iterator(e,t){return function i(r){let n;try{n=e.next(r)}catch(e){t(e)}n||t(new Error("ERROR: generator returned 'undefined' value and is not iterable"));const{done:s,value:o}=n||{done:!0,value:null};if(s)t(null,o);else if(o&&"function"==typeof o.then&&"function"==typeof o.catch)o.then(i,t);else{let e=setTimeout(()=>{i(o),clearTimeout(e)},0)}}}function makeDoWhilstGenerator(e,t){let i;return function*(){do{const t=e();t&&"function"==typeof t.then&&"function"==typeof t.catch?yield t.then(e=>i=e,e=>Promise.reject(e)):(i=t,yield i)}while(t(i))}}function timeout(e=0){return new Promise(t=>{let i=setTimeout(function(){clearTimeout(i),t()},e)})}function makeRetryGenerator(e,t){let i,r=!0,{times:n,timeout:s}=t;return function*(){do{n--;let t=r||"number"!=typeof s||0===s?e():(()=>timeout(s).then(e).catch(e=>Promise.reject(e)))();r=!1,t&&"function"==typeof t.then&&"function"==typeof t.catch?yield t.then(e=>i=e,e=>i={__isRejected:!0,e:e}):(i=t,yield i)}while(n&&i&&Object.hasOwnProperty.call(i,"__isRejected"));return i}}var utilities={safeAssign:safeAssign,map:map,parallel:parallel,handleRecursiveParallel:handleRecursiveParallel,settle:settle,iterator:iterator,doWhilst:makeDoWhilstGenerator,retry:makeRetryGenerator};function isNestedPromisifyAllObjectParam(e){return e&&"object"==typeof e}function setHandlers(e,t){return{success:e,failure:"function"==typeof t?t:void 0}}const thenables={try(e,t){const{success:i,failure:r}=setHandlers(function(t){try{return"function"==typeof e?e(t):Promisie.reject(new TypeError("ERROR: try expects onSuccess handler to be a function"))}catch(e){return Promisie.reject(e)}},t);return this.then(i,r)},spread(e,t){const{success:i,failure:r}=setHandlers(function(t){return"function"!=typeof t[Symbol.iterator]?Promisie.reject(new TypeError("ERROR: spread expects input to be iterable")):"function"!=typeof e?Promisie.reject(new TypeError("ERROR: spread expects onSuccess handler to be a function")):e(...t)},t);return this.then(i,r)},map(e,t,i){"number"==typeof t&&(i=t,t=void 0);const{success:r,failure:n}=setHandlers(function(t){return Array.isArray(t)?"function"!=typeof e?Promisie.reject(new TypeError("ERROR: map expects onSuccess handler to be a function")):Promisie.map(t,i,e):Promisie.reject(new TypeError("ERROR: map expects input to be an array"))},t);return this.then(r,n)},each(e,t,i){"number"==typeof t&&(i=t,t=void 0);const{success:r,failure:n}=setHandlers(function(t){return Array.isArray(t)?"function"!=typeof e?Promisie.reject(new TypeError("ERROR: each expects onSuccess handler to be a function")):Promisie.each(t,i,e):Promisie.reject(new TypeError("ERROR: each expects input to be an array"))},t);return this.then(r,n)},settle(e,t){let{success:i,failure:r}=setHandlers(function(t){if(!Array.isArray(t))return Promisie.reject(new TypeError("ERROR: settle expects input to be an array"));if("function"!=typeof e)return Promisie.reject(new TypeError("ERROR: settle expects onSuccess handler to be a function"));let i=t.map(t=>()=>e(t));return Promisie.settle(i)},t);return this.then(i,r)},retry(e,t,i){"object"==typeof t&&(i=t,t=void 0);let{success:r,failure:n}=setHandlers(function(t){return"function"!=typeof e?Promisie.reject(new TypeError("ERROR: retry expects onSuccess handler to be a function")):Promisie.retry(()=>e(t),i)},t);return this.then(r,n)},finally(e){let t=()=>"function"==typeof e?e():Promisie.reject(new TypeError("ERROR: finally expects handler to be a function"));return this.then(t,t)}};class Promisie extends Promise{constructor(e){super(e);for(let e in thenables)this[e]=thenables[e].bind(this)}static promisify(e,t){const i=function(...t){return new Promisie((i,r)=>{t.push(function(e,t){e?r(e):i(t)}),e.apply(this,t)})};return t?i.bind(t):i}static promisifyAll(e,t,i){const r=Object.assign({readonly:!0,recursive:!1},i);let n=Object.create(e);n=r.readonly?utilities.safeAssign(e):Object.assign(n,e);const s={};return Object.keys(n).forEach(e=>{if("function"==typeof n[e])s[`${e}Async`]=t?this.promisify(n[e],t):this.promisify(n[e]);else if(r.recursive){const i=n[e];isNestedPromisifyAllObjectParam(i)&&(s[e]=this.promisifyAll(i,t,r))}}),s}static async series(e){let t;for(let i=0;i<e.length;i++)t=await e[i](t);return t}static pipe(e){return async function(...t){const i=Object.assign([],e),r=i[0];return i[0]=function(){return r(...t)},await Promisie.series(e)}}static compose(e){return Promisie.pipe(e.reverse())}static map(e,t,i){const r="function"==typeof t?t:i;return Promisie.promisify(utilities.map)(r,e,t)}static each(e,t,i){return Promisie.map(e,t,i).then(()=>e)}static parallel(e,t,i={}){const{recursive:r=!1,concurrency:n}=i;return r&&(e=utilities.handleRecursiveParallel(e)),Promisie.promisify(utilities.parallel)(e,t,n)}static settle(e,t){return Promisie.promisify(utilities.settle)(e,t)}static iterate(e,t){return Promisie.promisify(utilities.iterator)(e(t))}static doWhilst(e,t){return Promisie.iterate(utilities.doWhilst(e,t),null)}static sleep(e){return new Promisie(t=>{setTimeout(()=>{t()},e)})}static retry(e,t){const{times:i=3,timeout:r=0}=t||{};return Promisie.iterate(utilities.retry(e,{times:i,timeout:r}),null)}}exports.default=Promisie;
