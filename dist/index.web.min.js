var promisie=function(t){"use strict";const e=Symbol("isPending"),n=Symbol("isFulfulled"),r=Symbol("isRejected"),i=Symbol("isPaused");class o{constructor(t){this.action=t.action,this.timeout=t.timeout||0,this.index=t.index,this.value=t.value,this[e]=!0,this[n]=!1,this[r]=!1,this.fulfill=function(t,e){if("number"==typeof this.timeout&&this.timeout>0){const n=setTimeout(()=>{this.value=t,e(t),clearTimeout(n)},this.timeout)}else this.value=t,e(t)}.bind(this),this.reject=function(t,e){if("number"==typeof this.timeout){const n=setTimeout(()=>{e(t),clearTimeout(n)},this.timeout)}else e(t)}.bind(this),this.next=void 0}resolve(t){return new Promise((e,n)=>{try{const r="function"==typeof this.action?this.action(t):this.action;if(r&&"function"==typeof r.then&&"function"==typeof r.catch)return r.then(t=>this.fulfill(t,e)).catch(t=>this.reject(t,n));this.fulfill(r,e)}catch(t){this.reject(t,n)}})}}function s(t){let e=[],n=t;for(;n;)e.push(n.value),n=n.next;return e}function c(t,e){for(;this.active<this.concurrency&&this.current;){this.active++;let n=this.current;this.current=n.next,n.action=this.action,n.resolve(n.value).then(n=>{0!=--this.active||this.current?this.resolve(t,e):t(s(this.root))},t=>{this[r]=!0,e(t)})}}class u{constructor(t){this.action=t.action,this.concurrency=t.concurrency||1/0,this.values=t.values||[],this.active=0,this.timeout=t.timeout||0,this.current=void 0,this[i]=!1,this[r]=!1,this.root=void 0,this.length=0,this.decompress=(t.decompress||s).bind(this)}insert(...t){for(let e=0;e<t.length;e++)if(this.length++,this.root){let n=this.root;for(;n&&n.next;)n=n.next;n.next=new o({index:e,action:void 0,value:t[e],timeout:this.timeout})}else this.root=new o({index:e,action:void 0,value:t[e],timeout:this.timeout});return this.current=this.root,this}resolve(t,e){return!this.current||this[r]||this[i]?null:t&&e?void c.call(this,t,e):new Promise((t,e)=>{c.call(this,t,e)})}}function l(t=0){return new Promise(e=>{let n=setTimeout(function(){clearTimeout(n),e()},t)})}var a={safeAssign:function(t){let e={};for(let n in t){let r=Object.getOwnPropertyDescriptor(t,n);r&&r.writable&&(e[n]=t[n])}return e},map:function(t,e,n,r){const i="function"==typeof n?n:r;return new u({action:t,concurrency:"number"==typeof n?n:void 0}).insert(...e).resolve().then(t=>i(null,t)).catch(i)},parallel:function(t,e,n,r){const i="function"==typeof n?n:r;return new u({action:t=>{const{operation:n,key:r}=t;if("function"==typeof n){if(Array.isArray(e)){const t=e;return Promise.all([n(...t),r])}return[n(e),r]}return[n,r]},concurrency:"number"==typeof n?n:void 0,decompress:t=>{const e={};let n=t;for(;n;){const[t,r]=n.value;e[r]=t,n=n.next}return e}}).insert(...Object.keys(t).map(e=>[t[e],e])).resolve().then(t=>i(null,t)).catch(i)},handleRecursiveParallel:function t(e){return Object.keys(e).reduce((n,r)=>(e[r]&&"object"==typeof e[r]?n[r]=(()=>p.parallel(t(e[r]))):n[r]=r,n),{})},settle:function(t,e,n){const r="function"==typeof e?e:n,i=[],o=[];return new u({action(t){if("function"==typeof t)try{const e=t();e&&"function"==typeof e.then&&"function"==typeof e.catch?e.then(t=>{i.push({value:t,status:"fulfilled"})},t=>{o.push({value:t,status:"rejected"})}):i.push({value:e,status:"fulfilled"})}catch(t){o.push({value:t,status:"rejected"})}else i.push({value:t,status:"fulfilled"});return null},decompress:t=>null,concurrency:"number"==typeof e?e:void 0}).insert(...t).resolve().then(()=>r(null,{fulfilled:i,rejected:o})).catch(r)},iterator:function(t,e){return function n(r){let i;try{i=t.next(r)}catch(t){e(t)}i||e(new Error("ERROR: generator returned 'undefined' value and is not iterable"));const{done:o,value:s}=i||{done:!0,value:null};if(o)e(null,s);else if(s&&"function"==typeof s.then&&"function"==typeof s.catch)s.then(n,e);else{let t=setTimeout(()=>{n(s),clearTimeout(t)},0)}}},doWhilst:function(t,e){let n;return function*(){do{const e=t();e&&"function"==typeof e.then&&"function"==typeof e.catch?yield e.then(t=>n=t,t=>Promise.reject(t)):(n=e,yield n)}while(e(n))}},retry:function(t,e){let n,r=!0,{times:i,timeout:o}=e;return function*(){do{i--;let e=r||"number"!=typeof o||0===o?t():(()=>l(o).then(t).catch(t=>Promise.reject(t)))();r=!1,e&&"function"==typeof e.then&&"function"==typeof e.catch?yield e.then(t=>n=t,t=>n={__isRejected:!0,e:t}):(n=e,yield n)}while(i&&n&&Object.hasOwnProperty.call(n,"__isRejected"));return n}}};function f(t,e){return{success:t,failure:"function"==typeof e?e:void 0}}const h={try(t,e){const{success:n,failure:r}=f(function(e){try{return"function"==typeof t?t(e):p.reject(new TypeError("ERROR: try expects onSuccess handler to be a function"))}catch(t){return p.reject(t)}},e);return this.then(n,r)},spread(t,e){const{success:n,failure:r}=f(function(e){return"function"!=typeof e[Symbol.iterator]?p.reject(new TypeError("ERROR: spread expects input to be iterable")):"function"!=typeof t?p.reject(new TypeError("ERROR: spread expects onSuccess handler to be a function")):t(...e)},e);return this.then(n,r)},map(t,e,n){"number"==typeof e&&(n=e,e=void 0);const{success:r,failure:i}=f(function(e){return Array.isArray(e)?"function"!=typeof t?p.reject(new TypeError("ERROR: map expects onSuccess handler to be a function")):p.map(e,n,t):p.reject(new TypeError("ERROR: map expects input to be an array"))},e);return this.then(r,i)},each(t,e,n){"number"==typeof e&&(n=e,e=void 0);const{success:r,failure:i}=f(function(e){return Array.isArray(e)?"function"!=typeof t?p.reject(new TypeError("ERROR: each expects onSuccess handler to be a function")):p.each(e,n,t):p.reject(new TypeError("ERROR: each expects input to be an array"))},e);return this.then(r,i)},settle(t,e){let{success:n,failure:r}=f(function(e){if(!Array.isArray(e))return p.reject(new TypeError("ERROR: settle expects input to be an array"));if("function"!=typeof t)return p.reject(new TypeError("ERROR: settle expects onSuccess handler to be a function"));let n=e.map(e=>()=>t(e));return p.settle(n)},e);return this.then(n,r)},retry(t,e,n){"object"==typeof e&&(n=e,e=void 0);let{success:r,failure:i}=f(function(e){return"function"!=typeof t?p.reject(new TypeError("ERROR: retry expects onSuccess handler to be a function")):p.retry(()=>t(e),n)},e);return this.then(r,i)},finally(t){let e=()=>"function"==typeof t?t():p.reject(new TypeError("ERROR: finally expects handler to be a function"));return this.then(e,e)}};class p extends Promise{constructor(t){super(t);for(let t in h)this[t]=h[t].bind(this)}static promisify(t,e){const n=function(...e){return new p((n,r)=>{e.push(function(t,e){t?r(t):n(e)}),t.apply(this,e)})};return e?n.bind(e):n}static promisifyAll(t,e,n){const r=Object.assign({readonly:!0,recursive:!1},n);let i=Object.create(t);i=r.readonly?a.safeAssign(t):Object.assign(i,t);const o={};return Object.keys(i).forEach(t=>{if("function"==typeof i[t])o[`${t}Async`]=e?this.promisify(i[t],e):this.promisify(i[t]);else if(r.recursive){const n=i[t];(function(t){return t&&"object"==typeof t})(n)&&(o[t]=this.promisifyAll(n,e,r))}}),o}static async series(t){let e;for(let n=0;n<t.length;n++)e=await t[n](e);return e}static pipe(t){return async function(...e){const n=Object.assign([],t),r=n[0];return n[0]=function(){return r(...e)},await p.series(t)}}static compose(t){return p.pipe(t.reverse())}static map(t,e,n){const r="function"==typeof e?e:n;return p.promisify(a.map)(r,t,e)}static each(t,e,n){return p.map(t,e,n).then(()=>t)}static parallel(t,e,n={}){const{recursive:r=!1,concurrency:i}=n;return r&&(t=a.handleRecursiveParallel(t)),p.promisify(a.parallel)(t,e,i)}static settle(t,e){return p.promisify(a.settle)(t,e)}static iterate(t,e){return p.promisify(a.iterator)(t(e))}static doWhilst(t,e){return p.iterate(a.doWhilst(t,e),null)}static sleep(t){return new p(e=>{setTimeout(()=>{e()},t)})}static retry(t,e){const{times:n=3,timeout:r=0}=e||{};return p.iterate(a.retry(t,{times:n,timeout:r}),null)}}return t.default=p,t}({});
