!function(e){"function"==typeof define&&define.amd?define(e):e()}(function(){"use strict";const e=require("path"),r=require("./series_generator"),t=require("./iterator"),n=require("./divisions"),i=require("./chainables"),l=require("./parallel_generator"),a=require("./settle_generator"),o=require("./dowhilst_generator"),c=require("./retry_generator"),{QUEUE:s}=require(e.join(__dirname,"../bin/index"));var u=function(e){return Object.keys(e).reduce((r,t)=>(e[t]&&"object"==typeof e[t]?r[t]=this.parallel.bind(this,u.call(this,e[t])):r[t]=e[t],r),Array.isArray(e)?[]:{})};module.exports={series_generator:r,series_iterator:t,divide:n,chainables:i,parallel_generator:l,settle_generator:a,_series:function(e,n){for(let r=0;r<e.length;r++)if("function"!=typeof e[r])return n(new TypeError(`ERROR: series can only be called with functions - argument ${r}: ${e[r]}`));let i=r(e);t(i,n)()},_map:function(e,r,t,n){Array.isArray(r)||n(new TypeError("ERROR: map can only be called with an Array")),n="function"==typeof t?t:n;let i=new s(e,t,r);return i.insert(...i.values).resolve().then(e=>n(null,e)).catch(n)},_parallel:function(e,r){try{let t=Array.isArray(e)?[]:{};return e[Symbol.iterator]=l(e,r,t),this.all(e).then(()=>t,e=>this.reject(e))}catch(e){return this.reject(e)}},_settle:function(e){try{let r=[],t=[];return e[Symbol.iterator]=a(e,r,t),this.all(e).then(()=>({fulfilled:r.length<1?r:r.sort((e,r)=>e.index-r.index),rejected:t.length<1?t:t.sort((e,r)=>e.index-r.index)}),e=>this.reject(e))}catch(e){return this.reject(e)}},safe_assign:function(e){let r={};for(let t in e){let n=Object.getOwnPropertyDescriptor(e,t);n&&n.writable&&(r[t]=e[t])}return r},isGenerator:function(e){return e.constructor===function*(){yield!0}.constructor},_dowhilst:function(e,r,n){try{let i=o(e,r)();t(i,n)()}catch(e){n(e)}},_iterate:function(e,r){t(e,r)()},_retry:function(e,r,n){try{let i=c.call(this,e,r)();t(i,n)()}catch(e){n(e)}},_handleRecursiveParallel:u}});
//# sourceMappingURL=promisie.umd.min.js.map
